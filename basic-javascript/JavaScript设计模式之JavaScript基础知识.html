<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>JavaScript设计模式之JavaScript基础知识</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>JavaScript设计模式之JavaScript基础知识</h1>
<h3>一、普通变量和引用变量之间的差别。</h3>
<p>在C/C++语言中，函数在传递值的方式有按值传递、按引用传递等几类，但是在JavaScript中，所有传递都是按引用传递的。但是，JavaScript中，不同变量类型在引用传递过程中的表现是不一样的，对于普通变量（Number、String等），按引用传递效果等同按值传递，对于Array和Object，按引用传递表现为按引用传递。示例如下：</br>
1、普通变量赋值</br></p>
<pre><code>var a='name1',b='name2';
a=b;
b='hehe';
console.log(a);//the result is: name2
console.log(b);//the result is: hehe
</code></pre>

<p>2、引用变量赋值Array</br></p>
<pre><code>var a=['a'],b=['b'];
a=b;
b.push('c');
console.log(a);//the result is: 'b' 'c'
console.log(b);//the result is: 'b' 'c'
</code></pre>

<p>2、引用变量赋值Object</br></p>
<pre><code>var a={name:'a'},b={name:'b'};
a=b;
b.name='c';
console.log(a);// the result is: Object {name: &quot;c&quot;}
console.log(b);// the result is: Object {name: &quot;c&quot;}
</code></pre>

<h3>二、普通变量和引用变量在类中的表现差别。</h3>
<p>对于某个类的实例对象，如果在该实例对象上改变其属性值（Array和Object）及方法，将会对该类的其它实例对象产生影响。示例如下：</p>
<pre><code>function Accommodation(){}
Accommodation.prototype.name='haha';
Accommodation.prototype.age={
    'person1':20,
    'person2':25
};
Accommodation.prototype.getName=function(){
    return this.name;
}
Accommodation.prototype.values=['a','b'];
var house1 = new Accommodation();
var house2 = new Accommodation();

console.log(house1.name);//haha
console.log(house2.name);//haha
console.log(house1.age);//Object {person1: 20, person2: 25}
console.log(house2.age);//Object {person1: 20, person2: 25}
console.log(house1.values);//(2) [&quot;a&quot;, &quot;b&quot;]
console.log(house2.values);//(2) [&quot;a&quot;, &quot;b&quot;]
console.log(house1.getName());//haha
console.log(house2.getName());//haha
house1.name='zeze';//true
house1.values.push('sdf');
house1.age.person1=100;
house1.__proto__.getName=function(){
    return 'i am change';
}
console.log(house1.__proto__==Accommodation.prototype)
console.log(house1.name);//zeze
console.log(house2.name);//haha
console.log(house1.age);//Object {person1: 100, person2: 25}
console.log(house2.age);//Object {person1: 100, person2: 25}
console.log(house1.values);//(3) [&quot;a&quot;, &quot;b&quot;, &quot;sdf&quot;]
console.log(house2.values);//(3) [&quot;a&quot;, &quot;b&quot;, &quot;sdf&quot;]
console.log(house1.getName());//i am change
console.log(house2.getName());//i am change
</code></pre>

<h3>三、实例对象上添加(删除)属性和方法与原型上添加和删除属性和方法的区别</h3>
<p>实例对象上添加属性和方法只对当前实例对象起作用，原型上添加属性和方法对该类的其它实例也会起作用。
1、实例对象上添加属性和方法
	function Accommodation(){}</p>
<pre><code>var house1 = new Accommodation();
var house2 = new Accommodation();
house1.getAge=function(){
    return 20;
}
console.log(house1.name);//a
console.log(house2.name);//undefined
console.log(house1.getAge());//20
console.log(house2.getAge());//error
</code></pre>

<p>2、原型上添加属性和方法
	function Accommodation(){}</p>
<pre><code>var house1 = new Accommodation();
var house2 = new Accommodation();
house1.__proto__.getAge=function(){//或Accommodation.prototype.getAge=...
    return 20;
}
house1.__proto__.name='a';//或Accommodation.prototype.name='a'
console.log(house1.name);//a
console.log(house2.name);//a
console.log(house1.getAge());//20
console.log(house2.getAge());//20
</code></pre>

<h3>四、this以及函数绑定（改变this作用域）</h3>
<h5>1、this</h5>
<p>说到this就得说说JavaScript的作用域。</br></p>
<ol>
<li>JavaScript具有<strong>函数级作用域</strong>。什么意思呢？</br>
也就是说，定义在函数中的变量只能在函数内部访问，不可以在函数外部访问。</li>
<li>JavaScript的作用域又具有<strong>词法（lexical）性质</strong>。什么意思呢？</br>
也就是说，函数运行在<strong>定义它的作用域<strong>，而不是</strong>调用它的作用域</strong>。</li>
</ol>
<p>而this,则恰好相反。this所代表的是一个上下文环境，而这个上下文环境<strong>大多数情况(对象中的嵌套函数除外)</strong>指代的是函数运行时封装这个函数的那个对象。示例如下：</br></p>
<pre><code>function testthis(){
    console.log(this ===window);
}
testthis();//(1)true
var obj={
    name:'haha',
    testfunc:function(){
        console.log(this===window);//(2)true
        console.log(this===obj);//(3)true
        testthis();//(4)true
    }
}
obj.testfunc();
</code></pre>

<ul>
<li>对于（1），毫无疑问，该函数运行时，封装这个函数的是window全局对象</li>
<li>对于（2），毫无疑问，该函数运行时，封装这个函数的是obj这个对象</li>
<li>对于（3），解释同（2）</li>
<li>对于（4），则有点特别，属于“大多数情况”之外的其它情况，也就是“对象中的嵌套函数”，虽然函数运行时，封装这个函数的仍然是obj对象，但是其this指代的却是window全局对象。这个特别的记住即可。</li>
</ul>
<p>this的指代并不是一成不变的，它可以通过函数绑定的方式进行改变，适用场合广泛。</p>
<h5>2、apply/call/bind改变this作用域</h5>
<pre><code>未完待续
</code></pre>

<h3>五、链式调用</h3>
<p>链式调用的实现方式很简单，只需要在函数结束前返回this即可。</p>
<pre><code>function Parent(){
    this.name='a';
    this.age=25;
}
Parent.prototype.getName=function(){
    console.log(this.name);
    return this;
}
Parent.prototype.getAge=function(){
    console.log(this.age);
    return this;
}
var obj = new Parent();
obj.getName().getAge();//a 25
</code></pre>

<h3>六、继承</h3>
<p>JavaScript继承的实现方式有很多种，陆续补充。</p>
<h5>1、类式继承（原型链）需要父类是类的形式。</h5>
<pre><code>function Parent(){
    this.name='a';
    this.age=25;
}
Parent.prototype.getName=function(){
    console.log(this.name);
    return this;
}
Parent.prototype.getAge=function(){
    console.log(this.age);
    return this;
}
function Child(){

}
console.log(new Child().__proto__);
console.log(new Child().constructor);
Child.prototype = new Parent();
console.log(new Child().__proto__);
console.log(new Child().__proto__.constructor);
console.log(Child.prototype.constructor===Child);//false
console.log(Child.prototype.constructor===Parent);//true
Child.prototype.constructor = Child;//注意这一步
console.log((new Child()).__proto__);
console.log(new Child().__proto__.constructor);
console.log(Child.prototype.constructor===Parent);//false
console.log(Child.prototype.constructor===Child);//true
</code></pre>

<p>原型继承有一步是将子类的原型的构造函数指向子类自身，否则将会导致子类实例化时的构造函数仍然是父类。这个在控制台貌似看不出来：
<img src="http://i.imgur.com/FH3XYeu.png" /></p>
<h5>2、create实现继承（类式继承）需要父类是类的形式。</h5>
<p>在ES5中就实现了create继承，create继承和上述原型继承效果类似。注意千万不要把create继承和浅复制、深复制、clone、assign等混为一谈。create继承与常规想象中的并不一样：</p>
<pre><code>var obj={
name:'liming',
age:20
};
console.log(obj);//Object {name: &quot;liming&quot;, age: 20}
var newobj=Object.create(obj);
console.log(newobj);//{}
</code></pre>

<p>你以为console.log(newobj)也会输出{name: &quot;liming&quot;, age: 20}吗？大错特错！。以上效果是“原型式继承”才可以办到的
看看Object.create的定义：</p>
<p>Object.create() 方法使用指定的<strong>原型对象</strong>和其<strong>属性</strong>创建了一个新的对象。参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" title="Object.create()">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create</a>
语法如下：</p>
<pre><code>Object.create(proto, [ propertiesObject ])
</code></pre>

<p>参数</p>
<p>proto
一个对象，应该是新创建的对象的原型。</p>
<p>propertiesObject
可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。注意：该参数对象不能是 undefined，另外只有该对象中自身拥有的可枚举的属性才有效，也就是说该对象的原型链上属性是无效的。</p>
<p>什么意思呢？也就是说，var A = Object.create(B),实现的效果是A.<strong>proto</strong>=B;所以上述例子达不到理想结果。
通过以上分析，可以知道，使用create可以很方便的实现继承：</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=23;
}
function Child(){
    Parent.call(this);
}
Child.prototype=Object.create(Parent.prototype);
//Child.prototype.constructor=Child;
var c=new Child();
console.log(c.name);//liming
console.log(c.constructor===Child);//false
console.log(Child.prototype.constructor===Child);//false
</code></pre>

<p>也就是说，Child.prototype=Object.create(Parent.prototype)等同于Child.prototype=new Parent();
子类的构造函数constructor仍然需要手工去纠正：Child.prototype.constructor=Child;</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=23;
}
function Child(){
    Parent.call(this);
}
Child.prototype=Object.create(Parent.prototype);
Child.prototype.constructor=Child;
var c=new Child();
console.log(c.name);//liming
console.log(c.constructor===Child);//true
console.log(Child.prototype.constructor===Child);//true
</code></pre>

<p>例子：
使用Object.create实现类式继承</p>
<pre><code>//Shape - superclass
function Shape() {
  this.x = 0;
  this.y = 0;
}

Shape.prototype.move = function(x, y) {
    this.x += x;
    this.y += y;
    console.info(&quot;Shape moved.&quot;);
};

// Rectangle - subclass
function Rectangle() {
  Shape.call(this); //call super constructor.
}

Rectangle.prototype = Object.create(Shape.prototype);

var rect = new Rectangle();

rect instanceof Rectangle //true.
rect instanceof Shape //true.

rect.move(1, 1); //Outputs, &quot;Shape moved.&quot;
</code></pre>

<p>如果你希望能继承到多个对象,则可以使用混入的方式。</p>
<pre><code>function MyClass() {
     SuperClass.call(this);
     OtherSuperClass.call(this);
}

MyClass.prototype = Object.create(SuperClass.prototype); //inherit
mixin(MyClass.prototype, OtherSuperClass.prototype); //mixin

MyClass.prototype.myMethod = function() {
     // do a thing
};
</code></pre>

<p>mixin函数会把超类原型上的函数拷贝到子类原型上，这里mixin函数没有给出,需要由你实现。一个和 mixin 很像的函数是  jQuery.extend。</p>
<p>使用Object.create 的 propertyObject 参数</p>
<pre><code>var o;

// 创建一个原型为null的空对象
o = Object.create(null);


o = {};
// 以字面量方式创建的空对象就相当于:
o = Object.create(Object.prototype);


o = Object.create(Object.prototype, {
  // foo会成为所创建对象的数据属性
  foo: { writable:true, configurable:true, value: &quot;hello&quot; },
  // bar会成为所创建对象的访问器属性
  bar: {
    configurable: false,
    get: function() { return 10 },
    set: function(value) { console.log(&quot;Setting `o.bar` to&quot;, value) }
}})


function Constructor(){}
o = new Constructor();
// 上面的一句就相当于:
o = Object.create(Constructor.prototype);
// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码


// 创建一个以另一个空对象为原型,且拥有一个属性p的对象
o = Object.create({}, { p: { value: 42 } })

// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:
o.p = 24
o.p
//42

o.q = 12
for (var prop in o) {
   console.log(prop)
}
//&quot;q&quot;

delete o.p
//false

//创建一个可写的,可枚举的,可配置的属性p
o2 = Object.create({}, { p: { value: 42, writable: true, enumerable: true, configurable: true } });
</code></pre>

<p>Polyfill</p>
<p>本polyfill的实现基于Object.prototype.hasOwnProperty。</p>
<pre><code>if (typeof Object.create != 'function') {
  // Production steps of ECMA-262, Edition 5, 15.2.3.5
  // Reference: http://es5.github.io/#x15.2.3.5
  Object.create = (function() {
    //为了节省内存，使用一个共享的构造器
    function Temp() {}

    // 使用 Object.prototype.hasOwnProperty 更安全的引用 
    var hasOwn = Object.prototype.hasOwnProperty;

    return function (O) {
      // 1. 如果 O 不是 Object 或 null，抛出一个 TypeError 异常。
      if (typeof O != 'object') {
        throw TypeError('Object prototype may only be an Object or null');
      }

      // 2. 使创建的一个新的对象为 obj ，就和通过
      //    new Object() 表达式创建一个新对象一样，
      //    Object是标准内置的构造器名
      // 3. 设置 obj 的内部属性 [[Prototype]] 为 O。
      Temp.prototype = O;
      var obj = new Temp();
      Temp.prototype = null; // 不要保持一个 O 的杂散引用（a stray reference）...

      // 4. 如果存在参数 Properties ，而不是 undefined ，
      //    那么就把参数的自身属性添加到 obj 上，就像调用
      //    携带obj ，Properties两个参数的标准内置函数
      //    Object.defineProperties() 一样。
      if (arguments.length &gt; 1) {
        // Object.defineProperties does ToObject on its first argument.
        var Properties = Object(arguments[1]);
        for (var prop in Properties) {
          if (hasOwn.call(Properties, prop)) {
            obj[prop] = Properties[prop];
          }
        }
      }

      // 5. 返回 obj
      return obj;
    };
  })();
}
</code></pre>

<h5>4、原型式继承（不需要父类，直接以对象字面量为父进行继承）</h5>
<p>未完待续</p>
<h5>3、apply/call实现继承</h5>
<p>未完待续</p>
<h3>七、arguments</h3>
<h5>1、常规方法（for遍历方法忽略）</h5>
<p>arguments是类数组，也称伪数组，但不是数组。arguments有length属性，但是没有数组的其它方法。</p>
<pre><code>function test(name,age,time){
    console.log(arguments);//(6) [1, 2, 3, 4, 5, 6, callee: function, Symbol(Symbol.iterator): function]
    console.log(arguments.length);//6
    console.log(Array.isArray(arguments));//false
    console.log(arguments.__proto__.constructor===Array);//false
    console.log(arguments.__proto__.constructor);//function Object() { [native code] }
    console.log(Array.prototype.slice.call(arguments));//[1, 2, 3, 4, 5, 6]
    console.log([].slice.call(arguments));//[1, 2, 3, 4, 5, 6]
    console.log(Array.prototype.slice.call(arguments,0));//[1, 2, 3, 4, 5, 6]
    console.log([].slice.call(arguments,0));//[1, 2, 3, 4, 5, 6]
}
test(1,2,3,4,5,6);
</code></pre>

<p>通常，需要将其转换为数组，方法是：Array.prototype.slice.call(arguments)或其它几种。首先改变slice作用域为arguments,然后后面的差数就是slice的参数，注意一下call和apply的区别就OK了。</p>
<h5>2、ES6方法</h5>
<p>八、Array几种方法
forEach,some,any,every,map,filter等，需要注意的是，他们的回调函数的参数是一样的，为如下排列格式</p>
<pre><code>arr.some(function(value,index,arr){

}); 
</code></pre>

<p>jQuery中也有遍历数组的方法$.each,但其参数和排列顺序于上述几种方法不同：</p>
<pre><code>$.each(arr,function(index,value){

});
</code></pre>

<h3>九、对象方法</h3>
<p>isExtensible和preventExtensions方法(不能增添属性)、freeze(不能添加属性，且已有的属性也不可改变)、getOwnPropertyDescriptor方法、获取属性键值keys、值values等。</p>
<pre><code>var obj={
    name:'liming',
    age:20
};
console.log(Object.isExtensible(obj));//true
obj.title='layaw';
console.log(obj);//Object {name: &quot;liming&quot;, age: &quot;20&quot;, title: &quot;layaw&quot;}
Object.preventExtensions(obj);
obj.rank=10;
console.log(obj);//Object {name: &quot;liming&quot;, age: &quot;20&quot;, title: &quot;layaw&quot;}
console.log(Object.isExtensible(obj));//false
Object.freeze(obj);
obj.age=30;
console.log(obj.age);//20
console.log(Object.getOwnPropertyDescriptor(obj,'name'));
//{value: &quot;liming&quot;, writable: true, enumerable: true, configurable: true}
console.log(Object.keys(obj));//[&quot;name&quot;, &quot;age&quot;, &quot;title&quot;]
console.log(Object.values(obj));//[&quot;liming&quot;, &quot;20&quot;, &quot;layaw&quot;]
</code></pre>

<h3>十、浅复制、深复制</h3>
<h3>十一、前端表格排序</h3>
<p>对表格进行排序，可以将表格的每一行数据以列号为键，表格元素为值构造一个对象字面量，然后将每行对应的对象字面量存放到数组中，转换成数组排序。对该数组排序可以采用JS自带的排序方法sort+自定义排序函数实现。</p>
<table>
	<thead>
	<tr>
	<th>姓名</th><th>年龄</th><th>...</th>
	</tr>
	</thead>
    <tr>
        <td>Liming</td><td>23</td><td>...</td>
    </tr>
</table>
<p>假定table_data是通过请求动态获取的表格数据，首先将每一行表格数据构造成以列号为键的对象字面量，因为键值不能为数值，这里通过'key'+i转换成合法的、唯一性的键值。</p>
<pre><code>var row_items=[];
$.each(table_data,function(i,item_array){
    var row_item={};
    $.each(item_array,function(j,item){
      var key='key'+j;
      row_item[key]=item;
    });
    row_items.push(row_item);
  });
  console.log(row_items);
</code></pre>

<p>然后对转而对数组进行排序，与普通数组进行排序不同的是，这里的数组元素是对象字面量。因此，需要自定义排序函数。这里需要注意的是：自定义排序函数的返回值分别是1、-1、0，而不是true、false;</p>
<pre><code>  row_items.sort(function(itemA,itemB){
    var sortKey='key'+sortIndex;
    if(sortType==='asc'){
      if(itemA[sortKey]&lt;itemB[sortKey]){
        return -1;
      }else if(itemA[sortKey]&gt;itemB[sortKey]){
        return 1;
      }else{
        return 0;
      }

    }else{
      if(itemA[sortKey]&lt;itemB[sortKey]){
        return 1;
      }else if(itemA[sortKey]&gt;itemB[sortKey]){
        return -1;
      }else{
        return 0;
      }
    }
  });
</code></pre>


</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
