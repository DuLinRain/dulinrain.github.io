# React事件

![](https://pic.rmb.bdstatic.com/bjh/news/5e0417ef788737694c0c0f55322c43c8.png)

### 事件委托

- React中的事件实际上都是做了**事件委托**的优化。
- 在16中是绑在**页面的根元素**上，即**document**上。
- 在17中则是绑在**React挂载的根节点**上。

![](https://pic.rmb.bdstatic.com/bjh/news/87d1a6be96ca5a99b7dfb6a9ace82f1f.png)

#### 为什么要改？有哪些影响？
在16中，如果你使用react监听了事件，在事件处理函数中使用了`e.stopPropagation()`。同时你也在document上手动绑定了原生事件：

    document.addEventListener('click', function() {
      // 会执行
    });

那么这个事件仍然会执行。因为原生事件本身就在document级别。和React 合成事件绑在同级别。阻止冒泡不起作用。

但是如果是在17中，因为事件是委托在挂载点，所以如果用了`e.stopPropagation()`, 那么document上是不会收到事件的。

这样改的好处是：
- 现在可以更加安全地进行新旧版本 React 树的嵌套
- 将 React 嵌入使用其他技术构建的应用程序变得更加容易。

### 合成事件

React中的事件并不是浏览器原生的事件，实际上是**合成事件**。

所谓**合成事件**，就是React按照W3C规范对各个浏览器事件进行包装，提供的**兼容多种浏览器**的事件，除了兼容性，还保留了和原生事件一样的API（stopPropagation 和 preventDefault）。

> 关键词：兼容性、API一致性。

我们在事件函数中收到的e其实都是**SyntheticEvent**的实例。

**如果想获取原生事件的对象怎么取呢？**

合成事件实例上的**nativeEvent**属性就是原生对象。

### 事件池

合成事件对象**e**并不是来一个创建一个，而是通过**事件池**进行管理，也就是说可以**复用**的。当某个**事件绑定的所有事件处理函数都处理完之后，合成事件对象的属性会被清空，继续复用**。也就是说**不需要重新创建事件对象，只需要重新赋值**。

比如下面的用法是无效的，因为这个**e**可能已经被复用了：

![](https://pic.rmb.bdstatic.com/bjh/news/b81b827bdd9f308e4c5bc2fde1549a0b.png)

**事件池在17版本已经删除了，为什么呢？**

因为这个东西只是为了提高在**旧浏览器中的性能**而存在的，对**现代浏览器没**任何性能提升。所以被删掉了。