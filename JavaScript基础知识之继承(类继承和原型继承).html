<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>JavaScript基础知识之继承</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>JavaScript基础知识之继承（类继承和原型继承）</h2>
<p>JavaScript的继承可分为两大类，一是<strong>类继承</strong>，二是<strong>原型继承</strong>。本文将讲述个人对这两种继承方式的理解。</p>
<h3>一、概述</h3>
<p>JavaScript的继承可分为两大类，一是<strong>类继承</strong>，二是<strong>原型继承</strong>。</p>
<h4>1.1、类继承</h4>
<p><strong>类继承</strong>是一种与C++等语言相似的继承方式。我们回顾一下C++语言类继承的主要特点：</p>
<p><strong>派生类（子类）的作用</strong></p>
<ol>
<li>吸收基类（父类）成员（除构造析构函数以外的所有成员）；</li>
<li>改造基类（父类）成员（根据继承方式调整基类成员的访问，函数在子类中的覆盖，以及虚函数在子类中的覆盖）；</li>
<li>添加新的成员；</li>
</ol>
<p><strong>构造函数的调用顺序</strong></p>
<ol>
<li>首先调用基类的构造函数</li>
<li>然后调用派生类的构造函数。</li>
</ol>
<p>因此，<strong>类继承</strong>的实现需要按照相应的步骤完成以上特点。</p>
<p>类继承的方式主要涉及到的是<strong>类</strong>，相应的操作也基本上是针对于<strong>类</strong>。</p>
<h4>1.2、原型继承</h4>
<p><strong>原型继承</strong>不再需要类的概念，使用原型继承时，不再需要定义类的结构，只需要使用已有对象直接创建一个新对象即可。原型继承操作的是<strong>对象</strong>。</p>
<h4>1.3、说明</h4>
<p><strong>类继承</strong>方式尽管名字听起来和原型没什么关系，但实际上，类继承也是通过原型来实现的，只是类继承和原型继承在实现的过程中有本质的差异。</p>
<h3>二、类继承</h3>
<h4>2.1、类继承的实现方式</h4>
<p>首先介绍类继承的实现方式：</p>
<p>首先定义基类（父类），我们首先定义了构造函数，并在构造函数中定义了三个属性（这里我们为求简便直接给属性定义了初值，而不是通过参数赋值），以及分别获取这三个属性的方法：</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=25;
    this.apples=[4,5,6,7];
}
Parent.prototype.getName=function(){
    console.log(this.name);
}
Parent.prototype.getAge=function(){
    console.log(this.age);
}
Parent.prototype.getApples=function(){
    console.log(this.apples);
}
</code></pre>

<p>然后，我们按类继承的方式定义派生类（子类）。按照类继承中“先调用父类的构造函数，再调用子类的构造函数”的特点，我们这样定义派生类的构造函数：</p>
<pre><code>function Children(){
    Parent.call();//先调用父类的构造函数
    this.nick='sb';//子类新增属性
    this.Bananas=[1,2,3];//子类新增属性
}
Children.prototype=new Parent();//实现继承
Children.prototype.getNick=function(){//子类新增方法
    console.log(this.nick);
}
Children.prototype.Bananas=function(){//子类新增方法
    console.log(this.Bananas);
}
</code></pre>

<p>在子类的构造函数中首先调用了父类的构造函数，然后子类又定义了两个自身的属性。
接下类我们实现非常关键的一步：<strong>子类继承父类</strong>。由于JavaScript中没有像C++语言中原生的extend方法来实现子类与父类之间的继承关系，因此我们仍然需要借助于JavaSript特有的原型链来实现子类继承父类。<code>Parent.prototype=new Parent()</code>这条语句实现了子类继承于父类。</p>
<p>然而，走到这一步并未结束。我们在控制台输入一下语句会得到如下结果：</p>
<p><img src="http://i.imgur.com/66YXPuw.png" /></p>
<p>这是为什么呢？</p>
<p>我们知道，在定义一个构造函数时，其默认的prototype是一个Object类型的实例，其默认的constructor是构造函数本身，那么，当我们手动的将它的prototype设置为另外一个对象的时候，其constructor也发生了相应的改变。举例如下：</p>
<p><img src="http://i.imgur.com/Lu2Un4l.png" /></p>
<p>因此，我们需要手动的将其调整回来，如下：</p>
<pre><code>Children.prototype.constructor=Children
</code></pre>

<p>最终，完整的类继承代码如下所示：</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=25;
    this.apples=[4,5,6,7];
}
Parent.prototype.getName=function(){
    console.log(this.name);
}
Parent.prototype.getAge=function(){
    console.log(this.age);
}
Parent.prototype.getApples=function(){
    console.log(this.apples);
}
function Children(){
    Parent.apply(this,arguments);//先调用父类的构造函数
    this.nick='sb';//子类新增属性
    this.Bananas=[1,2,3];//子类新增属性
}
Children.prototype=new Parent();//实现继承
Children.prototype.getNick=function(){//子类新增方法
    console.log(this.nick);
}
Children.prototype.Bananas=function(){//子类新增方法
    console.log(this.Bananas);
}
Children.prototype.constructor=Children;
</code></pre>

<h4>2.2、类继承的特点</h4>
<h5>2.2.1、每个对象拥有属于自己的一套属性和方法，互相不干扰。</h5>
<p>采用类继承方式，每个对象（实例）将拥有属于自己的一份属性和方法（无论这个属性和方法是否是继承于父类），改变一个对象的属性和方法时，不会影响其他对象的属性和方法。证明如下：</p>
<p><img src="http://i.imgur.com/kUQXGvX.png" /></p>
<p>我们首先声明2个对象实例，并分别获取他们的属性值：</p>
<p>可以看到，因为他们最初来自同一个类Children的实例化，所以他们拥有相同的值。然后我们逐渐改变child2实例的属性值，看看child1实例的属性值是否会跟着发生变化。如下：</p>
<p><img src="http://i.imgur.com/mDn94ms.png" /></p>
<p>可以看出，实例2的属性改变并不会影响实例1的属性。改变其中一个实例的方法，也不会影响另一个实例，这里我们不再用代码呈现。</p>
<h3>2.3、类继承的优缺点</h3>
<p>由前文所述可知：</p>
<ol>
<li>类继承可以确保每个实例拥有属于自己的一份属性和方法副本，这在很多场合是很有用的，当然，这也意味着内存消耗增加。</li>
<li>另一方面，类继承的实现方式相对复杂，稍后我们会介绍实现方式相对简单的原型继承。</li>
</ol>
<h3>2.4、如何理解“类继承可以确保每个实例拥有属于自己的一份属性和方法副本”？</h3>
<p>“类继承确保每个实例拥有属于自己的一份属性和方法副本”到底是如何做到的呢？其实仔细分析一下可以看出，类继承并没有什么特别高明之处，只不过是严格执行了类式C++一样的继承方式，也就是说，在派生类的构造函数调用了父类的构造函数，这一关键步骤确保了每个实例从父类得到了一个独一无二的副本，这个得到的方式应该类式于“拷贝”而非“引用”。如图：</p>
<p><img src="http://i.imgur.com/zncTv9L.png" /></p>
<p>当我们更改实例A的某个属性apples时，由于在实例A上就存在apples属性，所以，不会沿着原型链往上找，所以改变实例A的apples属性并不会影响其prototype上的属性，而由于实例A的属性和实例B的apples属性是独立的，所以改变实例A的apples属性也不会影响实例B的apples属性。</p>
<h3>2.5、简化类继承的实现方式——自定义extend函数</h3>
<p>从上面分析类继承的实现方式，可以看出，由于JavaScript的extend关键字并没有C++语言那样的作用，类继承主要通过两个比较重要的方法实现：</p>
<ol>
<li>派生类通过原型链继承基类。<code>Children.prototype=new Parent()</code></li>
<li>手工纠正派生类的constructor。<code>Children.prototype.constructor=Children</code></li>
</ol>
<p>这两个步骤合在一起，即可定义我们自己的extend函数，如下：</p>
<pre><code>function extend(subClass,superClass){
    subClass.prototype=new superClass();
    subClass.prototype.constructor=subClass;
}
</code></pre>

<p>但是，这样会有一个明显的缺点，当基类的构造函数比较庞大，或者需要执行大量的计算时，会影响派生类的创建效率，因此我们稍作改进：</p>
<pre><code>function extend(subClass,superClass){
    var F=function(){};//定义一个空函数
    F.prototype=superClass.prototype;//将其prototype指向父类的prototype
    subClass.prototype=new F();
    subClass.prototype.constructor=subClass;
}
</code></pre>

<p>可以理解为定义了一个空函数F，并将其prototype指向基类的prototype。这样实现的最终结果是一样的，但是避免了创建父类的新实例。
改进之后的类继承代码如下：</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=25;
    this.apples=[4,5,6,7];
}
Parent.prototype.getName=function(){
    console.log(this.name);
}
Parent.prototype.getAge=function(){
    console.log(this.age);
}
Parent.prototype.getApples=function(){
    console.log(this.apples);
}
function Children(){
    Parent.apply(this,arguments);//先调用父类的构造函数
    this.nick='sb';//子类新增属性
    this.Bananas=[1,2,3];//子类新增属性
}
extend(Children,Parent);//自定义extend
Children.prototype.getNick=function(){//子类新增方法
    console.log(this.nick);
}
Children.prototype.Bananas=function(){//子类新增方法
    console.log(this.Bananas);
}
</code></pre>

<p><strong>注意</strong>,事情到这里仍然还没有结束，因为我们仔细查看代码，发现基类被耦合在了派生类中，<code>Parent.apply(this,arguments)</code>。
我们知道<code>Parent.prototype.constructor=Parent</code>,所以我么可以在extend函数中使用一点技巧来解耦合。改进extend如下：</p>
<pre><code>function extend(subClass,superClass){
    var F=function(){};//定义一个空函数
    F.prototype=superClass.prototype;//将其prototype指向父类的prototype
    subClass.prototype=new F();
    subClass.prototype.constructor=subClass;
    subClass.super=superClass.prototype;//在subClass上定义静态属性super，来保存superClass.prototype
}
</code></pre>

<p>这样，我们的类继承实现代码改成如下形式：</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=25;
    this.apples=[4,5,6,7];
}
Parent.prototype.getName=function(){
    console.log(this.name);
}
Parent.prototype.getAge=function(){
    console.log(this.age);
}
Parent.prototype.getApples=function(){
    console.log(this.apples);
}
function Children(){
    //Parent.apply(this,arguments);//先调用父类的构造函数
    Children.super.constructor.apply(this,arguments);//注意这里改写成了这种形式
    this.nick='sb';//子类新增属性
    this.Bananas=[1,2,3];//子类新增属性
}
extend(Children,Parent);//自定义extend
Children.prototype.getNick=function(){//子类新增方法
    console.log(this.nick);
}
Children.prototype.Bananas=function(){//子类新增方法
    console.log(this.Bananas);
}
</code></pre>

<h3>三、原型继承</h3>
<p>前面已经说过，原型继承和类继承的较大区别是，原型继承不与类打交道，而是与对象打交道。</p>
<p><strong>原型继承</strong>与<strong>类继承<strong>的另外一个非常明显和非常重要的区别就是使用原型继承产生的所有对象</strong>共享同一份属性和方法副本</strong>。其中一个改变将会影响到<strong>其他所有对象</strong>。</p>
<h4>3.1、原型继承的实现方式</h4>
<p>实际上，我们知道，导致<strong>共享同一份属性和方法副本</strong>效应产生的原因就是，子类实例没有父类属性的独立副本，当通过子类实例去修改某属性值时，其会通过原型链往上查找，最后修改了父类属性，从而导致所谓的“其中一个改变将会影响到<strong>其他所有对象</strong>”。我们证明如下：</p>
<pre><code>function Parent(){
    this.name='liming';
    this.age=25;
    this.apples=[4,5,6,7];
}
Parent.prototype.getName=function(){
    console.log(this.name);
}
Parent.prototype.getAge=function(){
    console.log(this.age);
}
Parent.prototype.getApples=function(){
    console.log(this.apples);
}
function Children(){
    //删去了调用父类的构造函数
    this.nick='sb';//子类新增属性
    this.Bananas=[1,2,3];//子类新增属性
}
Children.prototype=new Parent();//实现继承
Children.prototype.getNick=function(){//子类新增方法
    console.log(this.nick);
}
Children.prototype.Bananas=function(){//子类新增方法
    console.log(this.Bananas);
}
Children.prototype.constructor=Children;
</code></pre>

<p>我们来做一些测试：</p>
<p><img src="http://i.imgur.com/lR75n69.png" /></p>
<p>可以看到，改变其中一个子类实例的name属性并不会改变另外一个实例的name，这是不是与我们所说的<strong>共享同一份属性和方法副本</strong>以及“其中一个改变将会影响到<strong>其他所有对象</strong>”矛盾呢？其实不然。分析如下:</p>
<p>子类没有调用父类的构造函数，也就是说，子类实例并没有父类的name属性，那么在读取name属性时，当前实例上没有，会沿着原型链查找，最终在原型链上找到了name属性。但是当设置属性时，<code>child2.name='xaiohong'</code>事实上并没有去改变原型链上的值，而是在自身的实例上定义了一个新的name属性。请看：</p>
<p><img src="http://i.imgur.com/eE4Bkf1.png" /></p>
<p>可以预见，当我们操作属性，而不是定义新的属性时，将会发生“其中一个改变将会影响到<strong>其他所有对象</strong>”的现象，而由于字符串和数值等操作都是不会改变原始值，所以，采用字符串或数值不好演示。</p>
<p>我们可以数组为例演示，如下</p>
<p><img src="http://i.imgur.com/jrocY4t.png" />
<img src="http://i.imgur.com/IRaxHxc.png" /></p>
<p>可见，却实起到了“其中一个改变将会影响到<strong>其他所有对象</strong>”的效果。并且我们可以断定，改变Bananas数组不会互相影响，因为两个实例自身拥有他们两的独立副本。</p>
<p><img src="http://i.imgur.com/7BQtRd2.png" /></p>
<p>由于原型继承主要针对对象，所以，常常采用如下方式写原型继承的实现方式：</p>
<pre><code>var obj={
    name:'liming',
    apples:[4,5,6,7],
    getName:function(){
        return name;
    }
};
function clone(obj){
    var F=function(){};
    F.prototype=obj;
    return new F();
}
var obj1=clone(obj);
</code></pre>

<h5>更优雅的实现方式</h5>
<p>采用Object.creat()实现。可以起到同样的效果。var obj1=Object.creat(obj)的实现结果是:</p>
<pre><code>obj1.__proto__=obj;
</code></pre>

<p>仔细想想这个和上面是不是一样的原理？证明一下：</p>
<pre><code>因为 obj1=new F()
所以
obj1.__proto__=F.prototype;
而F.prototype=obj
所以obj1.__proto__=obj
</code></pre>

<p>所以自定义clone和原生Object是等效的，只是Object功能更强大些，详见文章JavaScript基础知识之Object.create</p>
<h4>3.2、原型继承的优点</h4>
<p>节约内存，当然也得看场合适不适用了</p>
<h3>四、总结</h3>
<p>本文主要讲述了类继承和原型继承两种JavaScript继承方式，实际上他们的原理是很相似的，只是有些细节差异导致效果不同。相信看完本文，你对JavaScrip继承有了更深的了解，当然也有可能更迷糊。</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
