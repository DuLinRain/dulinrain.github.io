<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ES6之TypedArrays</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>ES6之Typed Arrays</h2>
<p>Typed Arrays是ES6用于处理二进制的数据结构，本文将讲述它们是如何工作的。</p>
<h3>一、概述</h3>
<p>先看一个例子：</p>
<p><img src="http://i.imgur.com/gYO69Im.png" /></p>
<p>从上面例子可以看出：</p>
<ol>
<li>Typed Array支持普通数组的方法和属性</li>
<li>Typed Array的实例通过buffer存储着数据，这些数据可以通过两种方式去访问。</li>
<li>一种是Typed Array，将buffer看成带索引的元素序列去访问，每种元素都是相同的类型</li>
<li>另一种是DataView，直接操作buffer，可以按任意字节偏移去访问数据。也就是说，你每次获取到的数据可以不是同一种类型</li>
</ol>
<p>到目前，有很多API都支持Typed Array：</p>
<ol>
<li>File API</li>
<li>XMLHttpRequest(Level 2)</li>
<li>Fetch API</li>
<li>Canvas</li>
<li>WebSocket</li>
<li>其它</li>
</ol>
<h3>二、介绍</h3>
<h4>2.1、为什么要用Typed Array</h4>
<p>我们在Web上遇到的数据基本上都是文本，比如JSON、XML、HTML、CSS、JavaScrip。JavaScrip内置的String类型足以处理这些数据。然而，直到几年前，JavaScript对二进制的处理仍然是力不从心的。直到2011年，处理二进制的标准（Typed Array）才产生，到目前为止，很多浏览器引擎都已经支持Typed Array了。在ES6中，Typed Array成为了JS语言的核心部分，并且拥有很多以前只能用于普通数组的的方法（比如map、filter）</p>
<p>Typed Array的主要用途在于：</p>
<ol>
<li><strong>处理二进制数据</strong>。比如在HTML Canvas中操作图像数据，解析二进制文件，处理二进制网络协议等等</li>
<li><strong>与Native API进行交互</strong>。Native API通常都以二进制格式接收和返回数据，这在传统的JS中既不好存储，也不好操作。这意味着，在每次调用时，你都需要进行某种形式的互相转换。Typed Array解决了这个问题。WebGL实际上是通过JS去操作硬件，实际上调用的是OpenGL API, Typed Array通常是这里面用到的数据类型。</li>
</ol>
<p>有两种对象通常和Typed Array相伴：</p>
<ol>
<li>Buffers。存储二进制数据的ArrayBuffer的实例</li>
<li>Views。提供方法用于获取二进制数据。一共有两种Views。</li>
<li>一种是Typed Array的实例（UintCArray，IntCArrat, FloatCArray等等。C代表数字）。它们和普通数据工作方式类似，不同的是，它们只能存储同一种数据类型</li>
<li>另一种是DataVies实例。可以按任意字节偏移去获取你想要的C类型的数据</li>
</ol>
<p>也就是说，数据存在buffer中，有两种呈现方式/视图（获取方式）。一种是通过Typed Array实例，一种是通过DataViews实例</p>
<p>下面是它们之间关系的结构图：</p>
<p><img src="http://i.imgur.com/Pe6bRyK.png" /></p>
<h4>2.2、元素类型</h4>
<p><img src="http://i.imgur.com/ozKC0XK.png" /></p>
<p>这里面有一个特殊的东西是Uint8C,它不支持DataViews，他只有Unit8ClampedArray这一种类型。这个类型用在Canvas中用来替换Canvas像素矩阵。Uint8C 和 Unit8 的唯一区别在于它们对于数据溢出的上溢和下溢处理不同。除非非它搞不定，建议永远不要用Unit8ClampedArray。</p>
<h4>2.3、处理上溢与下溢</h4>
<p>通常，学过C的都知道，当元素的值超过它所能表示的范围后都会采用模运算来将它们转换到合法范围内。对于有符号和无符号整数，这意味着：</p>
<ol>
<li>最大值+1被转换成最小值（对于有符号整数意味着转换成0）</li>
<li>最小值-1被转换成最大值</li>
</ol>
<p>例子如下：</p>
<p><img src="http://i.imgur.com/x22uTIc.png" />
<img src="http://i.imgur.com/NN6oFZj.png" />
<strong>而对于Uint8ClampedArray：</strong></p>
<p><img src="http://i.imgur.com/Ke7RF0x.png" /></p>
<p>可以看出，Uint8ClampedArray采取以下方式处理上溢与下溢：</p>
<ol>
<li>所有下溢的值都将转换成最小值</li>
<li>所有上溢的值都转换成最大值</li>
</ol>
<h4>2.4、字节顺序（大、小端）</h4>
<p>几乎所有学过网络编程的人都应该知道大端、小端的概念。当一个多字节数据存储时，它的字节顺序就很重要了：</p>
<ol>
<li>大端。最重要的字节最先出现（俗称从左到右）。比如0xABCD。首先出现的是0xAB,然后是0xCD</li>
<li>小端。最不重要的最先出现（俗称从右到左）。比如0xABCD。首先出现的是0xCD,然后是0xAB</li>
</ol>
<p>通常我们不关系大小端是因为CPU已经帮我们处理了，确保我们与Native API交互的时候大小端的一致性。Typed Array与Native API进行交互时，他们的字节序只与当前的平台有关，不会改变。</p>
<p>但是当进行跨平台交互时，比如说网络通信或者文件传输，不同平台的字节序不一样，DataViews让我们有能力指定字节序来获取或者写入数据。</p>
<p>引用维基百科的说法：</p>
<ol>
<li>大端通常用在各种网络协议中，比如IPV4、IPV6、TCP、UDP等等，所以大端又被称为“网络字节序”</li>
<li>小端通常用在微处理器中，这是由于英特尔的历史原因导致的</li>
</ol>
<p>用程序检测平台是大端还是小端很容易，方法就是写入一个数值（0x12345678）,读取第一个字节比较，看它是0x12还是0x78。或者是一个一个读出来，拼起来，看它是0x12345678还是0x78563412。如下：</p>
<p><img src="http://i.imgur.com/cfhRg8z.png" /></p>
<p>也有一些平台用的混合字节序，这里不再讨论</p>
<h4>2.5、负索引</h4>
<p>当使用[]进行索引访问时，索引必须是非负的，但是ArrayBuffer，TypedArray，DataViews的所有方法都可以使用负数索引。如果使用负索引，就相当于从后往前数。换句话说，起点就是负数索引+总长度得到的新索引值。比如</p>
<p><img src="http://i.imgur.com/CBcmmo1.png" /></p>
<p>但是对于偏移量则必须是非负，否则报错</p>
<h3>三、ArrayBuffer</h3>
<p>ArrayBuffer用于存储数据，Views（TypedArray,DataViews）使得你可以读取和改变它。要想创建一个DataViews，你需要给DataViews构造函数提供一个ArrayBuffer，而创建TypedArray既可以给构造函数提供ArrayBuffer，也可以不提供。</p>
<h4>3.1、ArrayBuffer构造函数</h4>
<p>ArrayBuffer构造函数的语法如下：</p>
<pre><code>ArrayBuffer(length: number)
</code></pre>

<p>new一下之后得到的是有number个字节的存储区，存储区里面每个字节都初始化为0</p>
<h4>3.2、ArrayBuffer的静态方法</h4>
<p>静态方法就是挂载在类名上的方法（通过类名直接调用而非实例调用）。ArrayBuffer提供了ArrayBuffer.isView(arg)静态方法。如果arg是一个对象，并且是一个view，那么才返回true。而只有DataViews和TypedArray拥有一个内部属性[[ViewedArrayBuffer]]，所以isView实际上就是检测arg是不是TypedArray或者DataViews的实例。</p>
<h3>四、Typed Arrays</h3>
<p>Typed Arrays有很多种，区别只在于他们每个元素的类型</p>
<ol>
<li>元素是整型的Typed Arrays：Uint8Array,Int8Array,Uint8ClampedArray,Uint16Array,Int16Array,Uint32Array,Int32Array</li>
<li>元素是浮点数的Typed Array：Float32Array,Float64Array</li>
</ol>
<h4>4.1、TypedArrays VS 普通数组</h4>
<p>TypedArray和普通数组非常相似，它们也有length属性，也可以通过索引访问，它们还拥有所有普通数组拥有的标准方法。但是它和普通数组有一下差别：</p>
<ol>
<li>所有的元素拥有同一种数据类型，设置一个值时将把它转换成数组元素的对应类型值</li>
<li>它们是连续的，不存在空洞。普通数组是可以存在无值（undefined）的空洞的</li>
<li>初始化为0（这和上一条区别是一致的）。new Array（10）将得到一个包含10个空洞的普通数组，而new Uint8Array（10）将得到包含10个0的数组</li>
<li>拥有一个存储区。TypedArray的数据并不是存储在实例中，而是存储在实例关联的ArrayBuffer中，通过实例名.buffer得到该存储区</li>
</ol>
<h4>4.2、TypedArrays是可迭代的</h4>
<p>由于TypedArray实施了以Symbol.iterator为键值得一个方法，所以他是可以迭代的。这意味着你可以用for...of去遍历：</p>
<p><img src="http://i.imgur.com/wkyCDY8.png" /></p>
<h4>4.3、TypedArray和普通数组相互转换</h4>
<h5>4.3.1、普通数组转TypeArray</h5>
<p>普通数组转TypedArray有太多方法：</p>
<h6>方法一</h6>
<pre><code>new Uint8Array([1,2,3])
</code></pre>

<h6>方法二</h6>
<pre><code>Uint8Array.from([1,2,3])
</code></pre>

<h6>方法三</h6>
<pre><code>Uint8Array.of(...[1,2,3])
</code></pre>

<h5>4.3.1、TypeArray转普通数组</h5>
<p>TypeArray转普通数组有太多方法：</p>
<h6>方法一</h6>
<pre><code>Array.prototype.slice.call(typedarray)
</code></pre>

<h6>方法二</h6>
<pre><code>[...typedarray]
</code></pre>

<h6>方法三</h6>
<pre><code>Array.from(typedarray)
</code></pre>

<h4>4.4、Species Pattern</h4>
<p>一些方法创建于this类似的实例。Species Pattern让你可以配置构造函数该如何工作，比如你从Array 派生出 MyArray,那么默认情况下map方法将产生MyArray的实例，如果你想它产生Array的实例，那么你需要用到Species Pattern。</p>
<h5>ArrayBuffer在下面几个地方使用Species Pattern：</h5>
<ol>
<li>ArrayBuffer.prototype.slice()</li>
<li>任意时刻ArrayBuffer被克隆</li>
</ol>
<h5>TypedArray在下面几个地方使用Species Pattern：</h5>
<ol>
<li>TypedArray<T>.prototype.filter()</li>
<li>TypedArray<T>.prototype.map()</li>
<li>TypedArray<T>.prototype.slice()</li>
<li>TypedArray<T>.prototype.subarray()</li>
</ol>
<h5>DataViews没有使用Species Pattern</h5>
<h4>4.5、TypedArrays的继承层次</h4>
<p>从前面一张结构图可以看出，所有TypedArray(比如Uint8Array)都是TypedArray的子类，在内部它是%TypedArray%,不可以被访问到，所有的实例方法都挂载在TypedArray.prototype上，静态方法挂在在TypedArray上。</p>
<h4>4.6、静态方法</h4>
<p>在学习了ES6之Classs时，有说过，所有静态方法也是可以继承的。</p>
<h5>4.6.1、TypedArray.of()</h5>
<p>函数签名：</p>
<pre><code>Typed&lt;T&gt;Array.of(...items)
</code></pre>

<p>返回值是一个Typed<T>Array实例</p>
<h5>4.6.1、TypedArray.from()</h5>
<p>函数签名：</p>
<pre><code>Typed&lt;T&gt;Array.from(source:Iterable&lt;T&gt;, mapfun?:T=&gt;U, thisArgs?)
</code></pre>

<p>返回值是一个Typed<T>Array实例</p>
<p>mapfun可以用与在转换之前完成某些操作。实际上就是把map和conversion两个步骤合二为一了。那么为什么要合二为一呢？仅仅是为了封装这么一个语法糖吗？实际上它有两个好处：</p>
<ol>
<li>减少了中间Array和TypedArray变量的产生</li>
<li>当将一个低精度的TypedArray转换到一个更高精度的TypedArray的时候，mapfun可以利用上后者的高精度（也就是说不会丢失精度）</li>
</ol>
<p>举个栗子：</p>
<p><img src="http://i.imgur.com/uW7b5Kh.png" /></p>
<p>可以看到，还是低精度的</p>
<p>利用mapfun参数：</p>
<p><img src="http://i.imgur.com/gT83pBX.png" /></p>
<p>可以看到，精度没有丢失</p>
<p>事实上，正式TypedArray与TypedArray互相转换时的精度问题激发了ES6的作者们引入了mapfun函数</p>
<h4>4.7、TypedArray独有的方法</h4>
<p>下面这些方法是普通数组没有而TypedArray有的：</p>
<p><img src="http://i.imgur.com/2UHWjfc.png" /></p>
<p>下面这些方法则是普通数组和TypedArray数组都有的：</p>
<p><img src="http://i.imgur.com/3Qa1EFg.png" />
<img src="http://i.imgur.com/OpfxQzZ.png" />
<img src="http://i.imgur.com/up66SVL.png" /></p>
<h4>4.8、Typed<T>Array构造函数</h4>
<p>每一种TypedArray的构造函数都有5种重载版本：</p>
<p><img src="http://i.imgur.com/6YuV6ME.png" /></p>
<h4>4.9、静态属性</h4>
<p>每种TypedArray都有1个静态属性：BYTES<em>PER</em>ELEMENT,表示每个元素占多少个字节</p>
<h4>4.10、原型属性</h4>
<p>每种TypedArray都有1个原型属性：BYTES<em>PER</em>ELEMENT,表示每个元素占多少个字节</p>
<h4>4.11、连接两个数组</h4>
<p>TypedArray没有和普通数组类似的concat方法，变通的方法是利用set函数+偏移量来处理，前提是保证前一个TypedArray有足够大的空间</p>
<p>typedarray.set(arrayOrTypedarray,offset)</p>
<h3>五、DataViews</h3>
<h4>5.1、构造函数</h4>
<pre><code> DataView(buffer, byteOffset=0, byteLength=buffer.byteLength-byteOffset)
</code></pre>

<p>创建一个DataView实例，其数据存储在buffer中，默认是从整个buffer创建view，但是也可以指定offeet和长度</p>
<h4>5.2、原型属性</h4>
<p><img src="http://i.imgur.com/Dnx5w8V.png" /></p>
<h3>六、支持TypedArrays的浏览器API</h3>
<h4>6.1、文件操作API</h4>
<p>文件操作API主要是利用FileReader的实例读取文件后的返回数据：</p>
<p><img src="http://i.imgur.com/zlkfqi3.png" /></p>
<h4>6.2、XMLHttpRequest</h4>
<p>XMLHttpRequest主要是指定响应类型为arraybuffer</p>
<p><img src="http://i.imgur.com/DzLpUr4.png" /></p>
<h4>6.3、Fetch API</h4>
<p>Fetch API和XMLHttpRequest类似，用于请求资源，但是Fetch API是基于Promise的：</p>
<p><img src="http://i.imgur.com/WhnkBle.png" /></p>
<h4>6.4、Canvas API</h4>
<p>常常用在操作图像数据的时候：</p>
<p><img src="http://i.imgur.com/VfBSxPV.png" /></p>
<h4>6.5、WebSocket API</h4>
<p><img src="http://i.imgur.com/fJd37eG.png" /></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
