##ES6之变量和作用域
###一、概述
ES6提供了新的方式用来声明变量：let和const。这两个几乎可以完全替代之前的var。

1. let和var很类似，但是let具有块级作用域，而var具有函数级作用域。
2. const和let类似，但是const声明的变量必须立即初始化，并且变量值不能更改。

**注意**,const变量值不能更改对普通类型和引用类型是一致的，但是在表现上有差异。

1. 对于普通类型，变量赋值是按值赋值的，也就是说，const a=123，那么a的值就是123，尝试改变它将会报错。
2. 对于引用类型（数组、对象等），const a=[1,2,3]，a的值只是一个引用而已，你虽然不能改变引用（也就是说不能讲a指到另外一个东西），但是a所引用的东西是可以改变的

######const值是基本数据类型：

![](http://i.imgur.com/Go53fFS.png)

######const值是引用类型

![](http://i.imgur.com/dUuX93V.png)

###二、let和const的块级作用域

1. var具有函数级作用域，函数中任何地方声明的变量，在刚进入函数时就已经存在，并被初始化为undefined。所以体现为变量提升（hoisted）。
2. let和const具有块级作用域，只有在包围它的最里面的那个块有效，不表现变量提升。

######var 函数级作用域：

![](http://i.imgur.com/xFGuIaR.png)

######let/const块级作用域

![](http://i.imgur.com/PS0DPBK.png)

######块级作用域意味着，里面的同名变量将屏蔽外面的同名变量，里面的操作不会影响外面的：

![](http://i.imgur.com/sGh8TXA.png)

######而函数级作用域则不同：

![](http://i.imgur.com/7gRyFIA.png)

###三、const产生不可更改的变量，但是不会导致变量的值不可更改
就是概述中所说的那个意思。
###四、时间死区（TDZ,temporal dead zone）
var有生命周期的概念（life cycle）,let和const有TDZ的概念。二者表现不同：

####3.1、var生命周期
1. 当进入到var变量所在的作用域（var的外围**function**）时，存储空间（或者所谓的bind）被创造，**变量被立即初始化为undefined**。
2. 这时候，设置和获取该变量都是可以的。体现为变量提升。
3. 当代码执行到变量声明的地方时，变量的值被初始化（如果有值初始化为该值，例如var a=1,如果无值，**仍保持undefined**）。
####3.2、let TDZ
1. 当进入到let变量所在的作用域（let的外围**块**）时，存储空间（或者所谓的bind）被创造，**变量不会被初始化**。
2. 这时候，设置和获取该变量都会报错。不体现变量提升。
3. 当代码执行到变量声明的地方时，变量的值被初始化（如果有值初始化为该值，例如var a=1,如果无值，**则初始化为undefined**）。
####3.3、const TDZ
const和let是类似的，区别就是const的变量必须被初始化，并且变量不可改变。
####3.4、为什么叫时间死区？
叫时间死区而不是叫位置死区是因为这个确实是和时间有关而不是和位置有关的。一个可能的误区就是：在TDZ里面，let变量声明前，只要出现该变量名就错误。这种想法是不对的，这种想法恰恰就是把它跟位置关联起来，而不是跟时间关联起来。实际上，即使该变量在let声明前出现，只要调用发生在死区结束之后，那么就是可行的。如下：

![](http://i.imgur.com/oJemzhg.png)

###四、循环中的let
var，let,const在下面几种循环中都是可以用的，但是效果是不同的。
####4.1、循环中的var和let差异
for循环的头部的var声明会产生一个单次绑定（single bind），这在通过循环定义函数的场合会存在问题。如下：

![](http://i.imgur.com/kcI8Lue.png)

箭头函数中的i都指向同一个绑定，这就是为什么他们执行之后返回同样的值。
在ES5中，通常使用IIFE的polyfill来解决这个问题，如下：

![](http://i.imgur.com/VVCf95E.png)

而在ES6中，let每次循环都将产生一次绑定，所以很方便的实现。如下：

![](http://i.imgur.com/IxpHXMi.png)
###五、函数参数
####5.1、局部变量与参数名重名问题。
函数中let声明的变量不允许与参数名相同，var无此限制。如下：

![](http://i.imgur.com/uKNsxPa.png)

####5.2、参数默认值及其TDZ
如果函数参数有默认值，那么就相当于用let声明了一个一个的参数，它们受制于它们的TDZ。
函数参数默认值的作用域和函数体的作用域是分开的（前者包含后者），这也就意味着，如果函数A参数的默认值是一个函数B，那么在这个函数B里面是拿不到函数A定义的东西的。如下：

![](http://i.imgur.com/R3WyBm1.png)

###六、全局对象
JS全局对象通常分为两种，在浏览器端是指window，在Node端是指global。ES6对他们做了区分。
1. 全局对象的所有属性都是全局变量，在全局作用域里面用var声明的变量或者定义的函数都是全局的，都会作为属性挂载在全局对象上。
2. 但是，采用let、const声明的变量以及class定义均不会挂载在全局对象上。

如下：

![](http://i.imgur.com/S7upJNQ.png)

这也是var和let的一个重要区别。

###七、class为什么不存在提升？
class本质上也是function，为什么class不允许提升呢？这是因为class里面extends语句后的的东西可以是任意表达式的值，而这个值必须在合适的位置计算。
###八、建议用ES6完全替换var
虽然var能做到let做不到的东西（挂载到window上），但是如果你确实想这样，你也可以用let手动挂载上去。如下

	let prop1 = '123';
	window.prop2=prop1;

所以，let是可以全面替换掉var的。
